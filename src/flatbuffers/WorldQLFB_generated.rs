// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod worldql_fb {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod messages {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INSTRUCTION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INSTRUCTION: u8 = 255;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INSTRUCTION: [Instruction; 13] = [
  Instruction::Heartbeat,
  Instruction::ZeroMQHandshake,
  Instruction::ZeroMQPortAssign,
  Instruction::LocalMessage,
  Instruction::GlobalMessage,
  Instruction::RecordCreate,
  Instruction::RecordRead,
  Instruction::RecordUpdate,
  Instruction::RecordDelete,
  Instruction::RecordReply,
  Instruction::AreaSubscribe,
  Instruction::AreaUnsubscribe,
  Instruction::Unknown,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Instruction(pub u8);
#[allow(non_upper_case_globals)]
impl Instruction {
  pub const Heartbeat: Self = Self(0);
  pub const ZeroMQHandshake: Self = Self(1);
  pub const ZeroMQPortAssign: Self = Self(2);
  pub const LocalMessage: Self = Self(3);
  pub const GlobalMessage: Self = Self(4);
  pub const RecordCreate: Self = Self(5);
  pub const RecordRead: Self = Self(6);
  pub const RecordUpdate: Self = Self(7);
  pub const RecordDelete: Self = Self(8);
  pub const RecordReply: Self = Self(9);
  pub const AreaSubscribe: Self = Self(10);
  pub const AreaUnsubscribe: Self = Self(11);
  pub const Unknown: Self = Self(255);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 255;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Heartbeat,
    Self::ZeroMQHandshake,
    Self::ZeroMQPortAssign,
    Self::LocalMessage,
    Self::GlobalMessage,
    Self::RecordCreate,
    Self::RecordRead,
    Self::RecordUpdate,
    Self::RecordDelete,
    Self::RecordReply,
    Self::AreaSubscribe,
    Self::AreaUnsubscribe,
    Self::Unknown,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Heartbeat => Some("Heartbeat"),
      Self::ZeroMQHandshake => Some("ZeroMQHandshake"),
      Self::ZeroMQPortAssign => Some("ZeroMQPortAssign"),
      Self::LocalMessage => Some("LocalMessage"),
      Self::GlobalMessage => Some("GlobalMessage"),
      Self::RecordCreate => Some("RecordCreate"),
      Self::RecordRead => Some("RecordRead"),
      Self::RecordUpdate => Some("RecordUpdate"),
      Self::RecordDelete => Some("RecordDelete"),
      Self::RecordReply => Some("RecordReply"),
      Self::AreaSubscribe => Some("AreaSubscribe"),
      Self::AreaUnsubscribe => Some("AreaUnsubscribe"),
      Self::Unknown => Some("Unknown"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Instruction {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Instruction {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Instruction {
    type Output = Instruction;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Instruction {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Instruction {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Instruction {}
// struct Vec3d, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vec3d(pub [u8; 24]);
impl Default for Vec3d { 
  fn default() -> Self { 
    Self([0; 24])
  }
}
impl std::fmt::Debug for Vec3d {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Vec3d")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec3d {}
impl flatbuffers::SafeSliceAccess for Vec3d {}
impl<'a> flatbuffers::Follow<'a> for Vec3d {
  type Inner = &'a Vec3d;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vec3d>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec3d {
  type Inner = &'a Vec3d;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vec3d>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vec3d {
    type Output = Vec3d;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Vec3d as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Vec3d {
    type Output = Vec3d;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Vec3d as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec3d {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> Vec3d {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f64,
    y: f64,
    z: f64,
  ) -> Self {
    let mut s = Self([0; 24]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<f64>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<f64>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_x(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const f64 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<f64>(),
      );
    }
  }

  pub fn y(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<f64>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<f64>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_y(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const f64 as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<f64>(),
      );
    }
  }

  pub fn z(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<f64>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<f64>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_z(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const f64 as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<f64>(),
      );
    }
  }

  pub fn unpack(&self) -> Vec3dT {
    Vec3dT {
      x: self.x(),
      y: self.y(),
      z: self.z(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3dT {
  pub x: f64,
  pub y: f64,
  pub z: f64,
}
impl Vec3dT {
  pub fn pack(&self) -> Vec3d {
    Vec3d::new(
      self.x,
      self.y,
      self.z,
    )
  }
}

pub enum RecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Record<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Record<'a> {
    type Inner = Record<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Record<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Record { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RecordArgs<'args>) -> flatbuffers::WIPOffset<Record<'bldr>> {
      let mut builder = RecordBuilder::new(_fbb);
      if let Some(x) = args.flex { builder.add_flex(x); }
      if let Some(x) = args.data { builder.add_data(x); }
      if let Some(x) = args.world_name { builder.add_world_name(x); }
      if let Some(x) = args.position { builder.add_position(x); }
      if let Some(x) = args.uuid { builder.add_uuid(x); }
      builder.finish()
    }

    pub fn unpack(&self) -> RecordT {
      let uuid = self.uuid().map(|x| {
        x.to_string()
      });
      let position = self.position().map(|x| {
        x.unpack()
      });
      let world_name = self.world_name().map(|x| {
        x.to_string()
      });
      let data = self.data().map(|x| {
        x.to_string()
      });
      let flex = self.flex().map(|x| {
        x.to_vec()
      });
      RecordT {
        uuid,
        position,
        world_name,
        data,
        flex,
      }
    }
    pub const VT_UUID: flatbuffers::VOffsetT = 4;
    pub const VT_POSITION: flatbuffers::VOffsetT = 6;
    pub const VT_WORLD_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_DATA: flatbuffers::VOffsetT = 10;
    pub const VT_FLEX: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Record::VT_UUID, None)
  }
  #[inline]
  pub fn position(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(Record::VT_POSITION, None)
  }
  #[inline]
  pub fn world_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Record::VT_WORLD_NAME, None)
  }
  #[inline]
  pub fn data(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Record::VT_DATA, None)
  }
  #[inline]
  pub fn flex(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Record::VT_FLEX, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Record<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"uuid", Self::VT_UUID, false)?
     .visit_field::<Vec3d>(&"position", Self::VT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"world_name", Self::VT_WORLD_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"data", Self::VT_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"flex", Self::VT_FLEX, false)?
     .finish();
    Ok(())
  }
}
pub struct RecordArgs<'a> {
    pub uuid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub position: Option<&'a Vec3d>,
    pub world_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<&'a str>>,
    pub flex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RecordArgs<'a> {
    #[inline]
    fn default() -> Self {
        RecordArgs {
            uuid: None,
            position: None,
            world_name: None,
            data: None,
            flex: None,
        }
    }
}
pub struct RecordBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RecordBuilder<'a, 'b> {
  #[inline]
  pub fn add_uuid(&mut self, uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Record::VT_UUID, uuid);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(Record::VT_POSITION, position);
  }
  #[inline]
  pub fn add_world_name(&mut self, world_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Record::VT_WORLD_NAME, world_name);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Record::VT_DATA, data);
  }
  #[inline]
  pub fn add_flex(&mut self, flex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Record::VT_FLEX, flex);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RecordBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Record<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Record<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Record");
      ds.field("uuid", &self.uuid());
      ds.field("position", &self.position());
      ds.field("world_name", &self.world_name());
      ds.field("data", &self.data());
      ds.field("flex", &self.flex());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RecordT {
  pub uuid: Option<String>,
  pub position: Option<Vec3dT>,
  pub world_name: Option<String>,
  pub data: Option<String>,
  pub flex: Option<Vec<u8>>,
}
impl Default for RecordT {
  fn default() -> Self {
    Self {
      uuid: None,
      position: None,
      world_name: None,
      data: None,
      flex: None,
    }
  }
}
impl RecordT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Record<'b>> {
    let uuid = self.uuid.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let position_tmp = self.position.as_ref().map(|x| x.pack());
    let position = position_tmp.as_ref();
    let world_name = self.world_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let data = self.data.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let flex = self.flex.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    Record::create(_fbb, &RecordArgs{
      uuid,
      position,
      world_name,
      data,
      flex,
    })
  }
}
pub enum EntityOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Entity<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Entity<'a> {
    type Inner = Entity<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Entity<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Entity { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EntityArgs<'args>) -> flatbuffers::WIPOffset<Entity<'bldr>> {
      let mut builder = EntityBuilder::new(_fbb);
      if let Some(x) = args.flex { builder.add_flex(x); }
      if let Some(x) = args.data { builder.add_data(x); }
      if let Some(x) = args.world_name { builder.add_world_name(x); }
      if let Some(x) = args.position { builder.add_position(x); }
      if let Some(x) = args.uuid { builder.add_uuid(x); }
      builder.finish()
    }

    pub fn unpack(&self) -> EntityT {
      let uuid = self.uuid().map(|x| {
        x.to_string()
      });
      let position = self.position().map(|x| {
        x.unpack()
      });
      let world_name = self.world_name().map(|x| {
        x.to_string()
      });
      let data = self.data().map(|x| {
        x.to_string()
      });
      let flex = self.flex().map(|x| {
        x.to_vec()
      });
      EntityT {
        uuid,
        position,
        world_name,
        data,
        flex,
      }
    }
    pub const VT_UUID: flatbuffers::VOffsetT = 4;
    pub const VT_POSITION: flatbuffers::VOffsetT = 6;
    pub const VT_WORLD_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_DATA: flatbuffers::VOffsetT = 10;
    pub const VT_FLEX: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity::VT_UUID, None)
  }
  #[inline]
  pub fn position(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(Entity::VT_POSITION, None)
  }
  #[inline]
  pub fn world_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity::VT_WORLD_NAME, None)
  }
  #[inline]
  pub fn data(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity::VT_DATA, None)
  }
  #[inline]
  pub fn flex(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Entity::VT_FLEX, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Entity<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"uuid", Self::VT_UUID, false)?
     .visit_field::<Vec3d>(&"position", Self::VT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"world_name", Self::VT_WORLD_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"data", Self::VT_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"flex", Self::VT_FLEX, false)?
     .finish();
    Ok(())
  }
}
pub struct EntityArgs<'a> {
    pub uuid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub position: Option<&'a Vec3d>,
    pub world_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<&'a str>>,
    pub flex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for EntityArgs<'a> {
    #[inline]
    fn default() -> Self {
        EntityArgs {
            uuid: None,
            position: None,
            world_name: None,
            data: None,
            flex: None,
        }
    }
}
pub struct EntityBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EntityBuilder<'a, 'b> {
  #[inline]
  pub fn add_uuid(&mut self, uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity::VT_UUID, uuid);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(Entity::VT_POSITION, position);
  }
  #[inline]
  pub fn add_world_name(&mut self, world_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity::VT_WORLD_NAME, world_name);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity::VT_DATA, data);
  }
  #[inline]
  pub fn add_flex(&mut self, flex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity::VT_FLEX, flex);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EntityBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EntityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Entity<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Entity<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Entity");
      ds.field("uuid", &self.uuid());
      ds.field("position", &self.position());
      ds.field("world_name", &self.world_name());
      ds.field("data", &self.data());
      ds.field("flex", &self.flex());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EntityT {
  pub uuid: Option<String>,
  pub position: Option<Vec3dT>,
  pub world_name: Option<String>,
  pub data: Option<String>,
  pub flex: Option<Vec<u8>>,
}
impl Default for EntityT {
  fn default() -> Self {
    Self {
      uuid: None,
      position: None,
      world_name: None,
      data: None,
      flex: None,
    }
  }
}
impl EntityT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Entity<'b>> {
    let uuid = self.uuid.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let position_tmp = self.position.as_ref().map(|x| x.pack());
    let position = position_tmp.as_ref();
    let world_name = self.world_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let data = self.data.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let flex = self.flex.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    Entity::create(_fbb, &EntityArgs{
      uuid,
      position,
      world_name,
      data,
      flex,
    })
  }
}
pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
    type Inner = Message<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Message<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Message { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MessageArgs<'args>) -> flatbuffers::WIPOffset<Message<'bldr>> {
      let mut builder = MessageBuilder::new(_fbb);
      if let Some(x) = args.flex { builder.add_flex(x); }
      if let Some(x) = args.position { builder.add_position(x); }
      if let Some(x) = args.entities { builder.add_entities(x); }
      if let Some(x) = args.records { builder.add_records(x); }
      if let Some(x) = args.world_name { builder.add_world_name(x); }
      if let Some(x) = args.sender_uuid { builder.add_sender_uuid(x); }
      if let Some(x) = args.parameter { builder.add_parameter(x); }
      builder.add_instruction(args.instruction);
      builder.finish()
    }

    pub fn unpack(&self) -> MessageT {
      let instruction = self.instruction();
      let parameter = self.parameter().map(|x| {
        x.to_string()
      });
      let sender_uuid = self.sender_uuid().map(|x| {
        x.to_string()
      });
      let world_name = self.world_name().map(|x| {
        x.to_string()
      });
      let records = self.records().map(|x| {
        x.iter().map(|t| t.unpack()).collect()
      });
      let entities = self.entities().map(|x| {
        x.iter().map(|t| t.unpack()).collect()
      });
      let position = self.position().map(|x| {
        x.unpack()
      });
      let flex = self.flex().map(|x| {
        x.to_vec()
      });
      MessageT {
        instruction,
        parameter,
        sender_uuid,
        world_name,
        records,
        entities,
        position,
        flex,
      }
    }
    pub const VT_INSTRUCTION: flatbuffers::VOffsetT = 4;
    pub const VT_PARAMETER: flatbuffers::VOffsetT = 6;
    pub const VT_SENDER_UUID: flatbuffers::VOffsetT = 8;
    pub const VT_WORLD_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_RECORDS: flatbuffers::VOffsetT = 12;
    pub const VT_ENTITIES: flatbuffers::VOffsetT = 14;
    pub const VT_POSITION: flatbuffers::VOffsetT = 16;
    pub const VT_FLEX: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn instruction(&self) -> Instruction {
    self._tab.get::<Instruction>(Message::VT_INSTRUCTION, Some(Instruction::Heartbeat)).unwrap()
  }
  #[inline]
  pub fn parameter(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_PARAMETER, None)
  }
  #[inline]
  pub fn sender_uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_SENDER_UUID, None)
  }
  #[inline]
  pub fn world_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_WORLD_NAME, None)
  }
  #[inline]
  pub fn records(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record>>>>(Message::VT_RECORDS, None)
  }
  #[inline]
  pub fn entities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Entity<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Entity>>>>(Message::VT_ENTITIES, None)
  }
  #[inline]
  pub fn position(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(Message::VT_POSITION, None)
  }
  #[inline]
  pub fn flex(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Message::VT_FLEX, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Instruction>(&"instruction", Self::VT_INSTRUCTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"parameter", Self::VT_PARAMETER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"sender_uuid", Self::VT_SENDER_UUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"world_name", Self::VT_WORLD_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Record>>>>(&"records", Self::VT_RECORDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Entity>>>>(&"entities", Self::VT_ENTITIES, false)?
     .visit_field::<Vec3d>(&"position", Self::VT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"flex", Self::VT_FLEX, false)?
     .finish();
    Ok(())
  }
}
pub struct MessageArgs<'a> {
    pub instruction: Instruction,
    pub parameter: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sender_uuid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub world_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub records: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record<'a>>>>>,
    pub entities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Entity<'a>>>>>,
    pub position: Option<&'a Vec3d>,
    pub flex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for MessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        MessageArgs {
            instruction: Instruction::Heartbeat,
            parameter: None,
            sender_uuid: None,
            world_name: None,
            records: None,
            entities: None,
            position: None,
            flex: None,
        }
    }
}
pub struct MessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_instruction(&mut self, instruction: Instruction) {
    self.fbb_.push_slot::<Instruction>(Message::VT_INSTRUCTION, instruction, Instruction::Heartbeat);
  }
  #[inline]
  pub fn add_parameter(&mut self, parameter: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_PARAMETER, parameter);
  }
  #[inline]
  pub fn add_sender_uuid(&mut self, sender_uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_SENDER_UUID, sender_uuid);
  }
  #[inline]
  pub fn add_world_name(&mut self, world_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_WORLD_NAME, world_name);
  }
  #[inline]
  pub fn add_records(&mut self, records: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Record<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_RECORDS, records);
  }
  #[inline]
  pub fn add_entities(&mut self, entities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Entity<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_ENTITIES, entities);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(Message::VT_POSITION, position);
  }
  #[inline]
  pub fn add_flex(&mut self, flex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_FLEX, flex);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("instruction", &self.instruction());
      ds.field("parameter", &self.parameter());
      ds.field("sender_uuid", &self.sender_uuid());
      ds.field("world_name", &self.world_name());
      ds.field("records", &self.records());
      ds.field("entities", &self.entities());
      ds.field("position", &self.position());
      ds.field("flex", &self.flex());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MessageT {
  pub instruction: Instruction,
  pub parameter: Option<String>,
  pub sender_uuid: Option<String>,
  pub world_name: Option<String>,
  pub records: Option<Vec<RecordT>>,
  pub entities: Option<Vec<EntityT>>,
  pub position: Option<Vec3dT>,
  pub flex: Option<Vec<u8>>,
}
impl Default for MessageT {
  fn default() -> Self {
    Self {
      instruction: Instruction::Heartbeat,
      parameter: None,
      sender_uuid: None,
      world_name: None,
      records: None,
      entities: None,
      position: None,
      flex: None,
    }
  }
}
impl MessageT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Message<'b>> {
    let instruction = self.instruction;
    let parameter = self.parameter.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sender_uuid = self.sender_uuid.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let world_name = self.world_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let records = self.records.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let entities = self.entities.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let position_tmp = self.position.as_ref().map(|x| x.pack());
    let position = position_tmp.as_ref();
    let flex = self.flex.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    Message::create(_fbb, &MessageArgs{
      instruction,
      parameter,
      sender_uuid,
      world_name,
      records,
      entities,
      position,
      flex,
    })
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  unsafe { flatbuffers::root_unchecked::<Message<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Message<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Message`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Message>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_message_unchecked`.
pub fn size_prefixed_root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Message>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Message` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Message`.
pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::root_unchecked::<Message>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
}
#[inline]
pub fn finish_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Messages
}  // pub mod WorldqlFb

